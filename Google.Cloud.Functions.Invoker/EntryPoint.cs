// Copyright 2020, Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using Google.Cloud.Functions.Framework;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Hosting;
using System;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Threading.Tasks;

namespace Google.Cloud.Functions.Invoker
{
    /// <summary>
    /// The entry point for the invoker. This is used automatically by the entry point generated by MS Build
    /// targets within the Google.Cloud.Functions.Invoker NuGet package.
    /// </summary>
    public static class EntryPoint
    {
        /// <summary>
        /// The environment variable used to detect the function target name, when not otherwise provided.
        /// </summary>
        public const string FunctionTargetEnvironmentVariable = "FUNCTION_TARGET";

        /// <summary>
        /// The environment variable used to detect the port to listen on.
        /// </summary>
        public const string PortEnvironmentVariable = "PORT";

        /// <summary>
        /// Starts a web server to serve the function in the specified assembly. This method is called
        /// automatically be the generated entry point.
        /// </summary>
        /// <param name="functionAssembly">The assembly containing the function to execute.</param>
        /// <param name="args">Arguments to parse </param>
        /// <returns>A task representing the asynchronous operation.
        /// The result of the task is an exit code for the process, which is 0 for success or non-zero
        /// for any failures.
        /// </returns>
        public static async Task<int> StartAsync(Assembly functionAssembly, string[] args)
        {
            // TODO: Catch exceptions and return 1, or just let the exception propagate? It probably
            // doesn't matter much. Potentially catch exceptions during configuration, but let any
            // during web server execution propagate.
            RequestDelegate handler = BuildHandler(functionAssembly, args);
            int port = DeterminePort(args);
            var builder = Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder => webBuilder
                    .ConfigureKestrel(serverOptions => serverOptions.Listen(IPAddress.Any, port))
                    .Configure(app => app.Run(handler))
                );
            await builder.Build().RunAsync();
            return 0;
        }

        private static RequestDelegate BuildHandler(Assembly functionAssembly, string[] args)
        {
            // TODO: Better command line parsing, e.g. --target=xyz --port=5000
            var target = args.FirstOrDefault() ?? Environment.GetEnvironmentVariable(FunctionTargetEnvironmentVariable);
            if (string.IsNullOrEmpty(target))
            {
                throw new Exception("No target provided");
            }
            var type = functionAssembly.GetType(target);
            if (type is null)
            {
                throw new Exception($"Can't load target type '{target}'");
            }
            var instance = Activator.CreateInstance(type);
            return instance switch
            {
                IHttpFunction function => context => function.HandleAsync(context),
                _ => throw new Exception("Function doesn't support known interfaces")
            };
        }

        private static int DeterminePort(string[] args)
        {
            var environmentVariable = Environment.GetEnvironmentVariable(PortEnvironmentVariable);
            if (!string.IsNullOrEmpty(environmentVariable))
            {
                if (!int.TryParse(environmentVariable, NumberStyles.None, CultureInfo.InvariantCulture, out var parsed))
                {
                    throw new Exception($"Can't parse {PortEnvironmentVariable} environment variable value '{environmentVariable}'");
                }
                return parsed;
            }
            // TODO: Parse args
            return 8080;
        }
    }
}
