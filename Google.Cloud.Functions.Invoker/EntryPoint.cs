// Copyright 2020, Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using Google.Cloud.Functions.Framework;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Hosting;
using System;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Threading.Tasks;

namespace Google.Cloud.Functions.Invoker
{
    /// <summary>
    /// The entry point for the invoker. This is used automatically by the entry point generated by MS Build
    /// targets within the Google.Cloud.Functions.Invoker NuGet package.
    /// </summary>
    public static class EntryPoint
    {
        /// <summary>
        /// The environment variable used to detect the function target name, when not otherwise provided.
        /// </summary>
        public const string FunctionTargetEnvironmentVariable = "FUNCTION_TARGET";

        /// <summary>
        /// The environment variable used to detect the port to listen on.
        /// </summary>
        public const string PortEnvironmentVariable = "PORT";

        /// <summary>
        /// Starts a web server to serve the function in the specified assembly. This method is called
        /// automatically be the generated entry point.
        /// </summary>
        /// <param name="functionAssembly">The assembly containing the function to execute.</param>
        /// <param name="args">Arguments to parse </param>
        /// <returns>A task representing the asynchronous operation.
        /// The result of the task is an exit code for the process, which is 0 for success or non-zero
        /// for any failures.
        /// </returns>
        public static async Task<int> StartAsync(Assembly functionAssembly, string[] args)
        {
            // TODO: Catch exceptions and return 1, or just let the exception propagate? It probably
            // doesn't matter much. Potentially catch exceptions during configuration, but let any
            // during web server execution propagate.
            var environment = FunctionEnvironment.Create(functionAssembly, args, EnvironmentVariableProvider.System);
            var builder = Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder => webBuilder
                    .ConfigureKestrel(serverOptions => serverOptions.Listen(environment.Address, environment.Port))
                    .Configure(app => app.Run(environment.RequestHandler))
                );
            await builder.Build().RunAsync();
            return 0;
        }
    }
}
